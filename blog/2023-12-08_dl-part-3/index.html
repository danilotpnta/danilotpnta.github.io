<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Danilo Toapanta">
<meta name="dcterms.date" content="2023-12-08">
<meta name="description" content="Description of this Post">

<title>Danilo Toapanta - DL Part 3</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../assets/danilo.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<link href="../../site_libs/quarto-contrib/fontawesome6-0.1.0/all.css" rel="stylesheet">
<link href="../../site_libs/quarto-contrib/fontawesome6-0.1.0/latex-fontsize.css" rel="stylesheet">
<link href="../../site_libs/quarto-contrib/material-icons-0.14.2/mi.css" rel="stylesheet">
<script>
window.MathJax = {
  tex: {
    tags: 'ams'
  }
};
</script>
<link rel="shortcut icon" href="../../../../../../../../../../../assets/danilo.ico">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../css/index-posts.css">
<link rel="stylesheet" href="../css/custom_page_width/800px.css">
</head>

<body class="floating nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title"><span id="danilo_topanta_brand"> Danilo Toapanta</span> <a id="mysite" class="mysite" href="../../../../../sites/">MySites</a></span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html" rel="" target="">
 <span class="menu-text"><span id="home-welcome-msg">Home</span></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog/index.html" rel="" target="">
 <span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../projects/index.html" rel="" target="">
 <span class="menu-text">Projects</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about/index.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/danilotpnta?tab=repositories" rel="" target="_blank"><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full blog-page" style="display: none;">
    <div class="quarto-title-banner page-columns page-full">
        <div class="quarto-title column-body">
            <h1 class="title">DL Part 3</h1>
                
            <!-- Description Block -->
                        <div>
                <div class="description">
                    Description of this Post
                </div>
            </div>
                        
            <!-- Categories Block -->
                                            <div class="quarto-categories">

                    <!-- Display Categories -->
                                            <div class="quarto-category">
                            <a href="../../blog/#category=All">
                                All
                            </a>
                        </div> 
                                            <div class="quarto-category">
                            <a href="../../blog/#category=TAGS">
                                TAGS
                            </a>
                        </div> 
                    
                    <!-- Display Tags if any -->
                                    </div>
                            
        </div>
    </div>


    
    <div class="quarto-title-meta">

        <div>
        <div class="quarto-title-meta-heading">Author</div>
        <div class="quarto-title-meta-contents">
                 <p><a href="https://danilotpnta.github.io/">Danilo Toapanta</a> </p>
              </div>
      </div>
        
        <div>
        <div class="quarto-title-meta-heading">Published</div>
        <div class="quarto-title-meta-contents">
          <p class="date">December 8, 2023</p>
        </div>
      </div>
      
        
      </div>
      

    
</header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
    
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block page-columns page-full" id="quarto-document-content">
<script>
    var currentUrl = window.location.href;
    var index_init_post = currentUrl.lastIndexOf("/20");
    var string_init_post= currentUrl.slice(index_init_post, index_init_post+3 );

    // console.log("currentUrl: " + currentUrl);
    // console.log("index: " + index_init_post);
    // console.log("string: " + string_init_post);

    // If is equal to /blog/20... then make navbar title READING MODE
    if (string_init_post === "/20"){
        let mysite = document.getElementById("mysite");
        mysite.classList.add("mysite-change");

        let navbar = document.getElementById("danilo_topanta_brand");
        navbar.classList.add("navbar-brand-change");

        // This will render a new title saying READING DANILOS BLOG
        // navbar.innerHTML = 'You are Reading Danilo\'s Blog<span style="font-size:35px; vertical-align: middle; opacity: 0.65; padding-bottom: 6px; padding-left: 14px;" class="material-icons-round"> auto_awesome </span>';
        
        const smallDevice = window.matchMedia("(min-width: 570px)");
        smallDevice.addListener(handleDeviceChange);

        function handleDeviceChange(mediaQuery) {
            if (mediaQuery.matches) {
                navbar.innerHTML = "";
                // navbar.innerHTML = "<-- You are Reading Danilo's Blog -->";
            } else  {
                navbar.innerHTML = "Danilo Toapanta";
            }
        }

        // Run it initially
        handleDeviceChange(smallDevice);

        let link = document.getElementsByClassName("navbar-brand")[0];
        link.classList.add("disablePointerEvents");

        let brand_container = document.getElementsByClassName("navbar-brand-container")[0];
        brand_container.classList.add("navbar-brand-container-new-padding");

    }
</script>


<!-- <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Running my first Marathon</h1>
                  <div>
        <div class="description">
          I will be running at the 42km TCS Amsterdam 2023, 15th October
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">News</div>
              </div>
                  </div>
  </div> -->

  <!-- ---
  coming-soon: true
  tags: [Spanish]
  --- -->








<main id="title-block-header" class="quarto-title-block default page-columns page-full" style="padding-bottom: 40px;">

    <div class="quarto-title column-body" style="margin-bottom: 1em;">
        <h1 class="title" style="padding-bottom:8px" ;="">DL Part 3</h1>
        
        <!-- Description Block -->
                    <div>
                <div class="description">
                    Description of this Post
                </div>
            </div>
        
        <!-- Categories Block -->
                    
                <!-- Display Categories -->
                <div class="quarto-categories">
                    <!-- <div id="tag-icon-blog" class="quarto-category tags-title">
                        <i class="fa-solid fa-hashtag" ></i> Categories:
                    </div> -->

                                            <div id="All" class="quarto-category">
                            <a href="../../blog/#category=All">
                                All
                            </a>
                        </div>
                                            <div id="TAGS" class="quarto-category">
                            <a href="../../blog/#category=TAGS">
                                TAGS
                            </a>
                        </div>
                                    </div>
                


                <div class="quarto-categories tag-categories">
                    
                    <!-- Tags Icon  -->
                    <!-- <div id="tag-icon-blog" class="quarto-category tags-title"> -->
                        <!-- <i class="fa-solid fa-tag" ></i> Tags: -->
                        <!-- <i class="fa-solid fa-hashtag" ></i> Tags: -->
                        <!-- <span class="material-icons-outlined" >local_offer</span> Tags: -->
                        <!-- / -->
                    <!-- </div> -->

                    <!-- Display Tags -->
                                            <div id="All-from-here" class="quarto-category tags-title" style="display: none;">
                            <a href="../../blog/#category=All">
                               <!-- <span class="hasth-tag">
                                #
                                </span> -->
                                All
                            </a>
                        </div>
                                            <div id="TAGS-from-here" class="quarto-category tags-title" style="display: none;">
                            <a href="../../blog/#category=TAGS">
                               <!-- <span class="hasth-tag">
                                #
                                </span> -->
                                TAGS
                            </a>
                        </div>
                    
                    
                </div>

                    
    </div>


    
    <div class="quarto-title-meta">

        <div>
        <div class="quarto-title-meta-heading">Author</div>
        <div class="quarto-title-meta-contents">
                 <p><a href="https://danilotpnta.github.io/">Danilo Toapanta</a> </p>
              </div>
      </div>
        
        <div>
        <div class="quarto-title-meta-heading">Published</div>
        <div class="quarto-title-meta-contents">
          <p class="date">December 8, 2023</p>
        </div>
      </div>
      
        
      </div>
      

    <!-- Current link: Font-awesome, Google icons, Bootstrap icons -->
    
</main>

<!-- \mathbfcal{I} -->
<section id="q1.1" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="q1.1"><span class="header-section-number">1</span> Q1.1</h2>
<ol type="1">
<li>We sample <span class="math inline">\(\textbf{z}_n\)</span> from the the normal distribution <span class="math inline">\(\mathcal(N)(0, \textbf{\textit{I}}_D)\)</span></li>
<li></li>
</ol>
</section>
<section id="q1.2" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="q1.2"><span class="header-section-number">2</span> Q1.2</h2>
<center>
<img src="2023-12-08-20-31-16.png" class="w350 img-fluid">
</center>
<pre></pre>
<ol type="1">
<li><p>If we use Montecarlo to approximate <span class="math inline">\(\log p(\textbf{x}_n)\)</span> we will be sampling <span class="math inline">\(\textbf{z}_{n}^{(l)}\)</span> from the prior distribution <span class="math inline">\(p(\textbf{z}_n)\)</span>. However, we can see that for most of these samples <span class="math inline">\(p(\textbf{x}_n|\textbf{z}_n^{(l)})\)</span> will be close to zero. This is a problem because we see that in order to sample <span class="math inline">\(\textbf{z}_n\)</span> which is then used to compute <span class="math inline">\(p(\textbf{x}_n|\textbf{z}_n^{(l)})\)</span> we want to fall in the small region represented by the posterior (depicted with blue line contours). Thus we would be sampling many times but only a small portion of those samples would be beneficial to approximate <span class="math inline">\(\log p(\textbf{x}_n)\)</span> thereby not an efficient method.</p></li>
<li><p>As we can see in the graph this is a 2-dimensional latent space showing the prior and the posterior distributions. If we would increase the dimensionality of this space (the dimensionality of <span class="math inline">\(\textbf{z}_n\)</span> increases as well) then effectively we are increasing the region from which we can sample <span class="math inline">\(\textbf{z}_n\)</span>. Thus, to get samples that contribute to compute <span class="math inline">\(\log p(\textbf{x}_n)\)</span> we would have to sample even more which is inefficient.</p></li>
</ol>
</section>
<section id="q1.3" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="q1.3"><span class="header-section-number">3</span> Q1.3</h2>
<p>Because the term <span class="math inline">\(KL(q(\textbf{z}_n | \textbf{x}_n) || p(\textbf{z}_n | \textbf{x}_n) ))≥ 0\)</span> is always positive. It follows that:</p>
<p><span class="math display">\[
\begin{align*}
\log p(\textbf{x}_n) - KL(q(\textbf{z}_n | \textbf{x}_n) || p(\textbf{z}_n | \textbf{x}_n) )) &amp;= \mathbb{E}_{q (\textbf{z}_n | \textbf{x}_n)} [\log p(\textbf{x}_n | \textbf{z}_n)] - KL(q(\textbf{z}_n | \textbf{x}_n) || p(\textbf{z}_n))\\
\log p(\textbf{x}_n) &amp;≥ \mathbb{E}_{q (\textbf{z}_n | \textbf{x}_n)} [\log p(\textbf{x}_n | \textbf{z}_n)] - KL(q(\textbf{z}_n | \textbf{x}_n) || p(\textbf{z}_n)) \tag{2}
\end{align*}
\]</span> Therefore the RHS of the equation (2) is a lower bound for <span class="math inline">\(\log p(x)\)</span>.</p>
</section>
<section id="q1.4" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="q1.4"><span class="header-section-number">4</span> Q1.4</h2>
<p>When the lower bound is pushed up effectively the <span class="math inline">\(\log p(\textbf{x}_n)\)</span> is being maximized. Conversely this makes <span class="math inline">\(KL(q(\textbf{z}_n | \textbf{x}_n) || p(\textbf{z}_n | \textbf{x}_n) ))\)</span> to be minimized. This implies:</p>
<ol type="1">
<li>The gap to the log-liklelihood <span class="math inline">\(\log p(\textbf{x}_n)\)</span> tightens. This in turn means we have a better generative model.</li>
<li>If we minimize <span class="math inline">\(KL(q(\textbf{z}_n | \textbf{x}_n) || p(\textbf{z}_n | \textbf{x}_n) ))\)</span> that means <span class="math inline">\(q (\textbf{z}_n | \textbf{x}_n)\)</span> will approximate to the true posterior <span class="math inline">\(p(\textbf{z}_n | \textbf{x}_n))\)</span>. This in turn means that we have a better latent representation. This also means that the problem of <span class="math inline">\(p(\textbf{z}_n | \textbf{x}_n) )\)</span> not being tractable is solved.</li>
</ol>
</section>
<section id="q1.4-1" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="q1.4-1"><span class="header-section-number">5</span> Q1.4</h2>
<center>
<img src="2023-12-09-02-06-15.png" class="w475 img-fluid">
</center>
<pre></pre>
<p>Img Source at: lilianweng.github.io</p>
<ul>
<li><p>In the first case the term reconstruction is appropriate because <span class="math inline">\(\mathbb{E}_{q_{\phi} (\textbf{z}_n | \textbf{x}_n)} [\log p(\textbf{x}_n | \textbf{z}_n)]\)</span> represents the expected value of <span class="math inline">\(x\)</span> if we were to sample <span class="math inline">\(z_n\)</span> from the approximated posterior <span class="math inline">\(q_{\phi}(\textbf{z}_n | \textbf{x}_n)\)</span> and then reconstruct it using <span class="math inline">\(p_{\theta}(\textbf{x}_n | \textbf{z}_n) )\)</span>. In other words how well the model predicts/reconstructs an observation from a sample from the variational posterior.</p></li>
<li><p>For the second case the term regularization is appropriate because the KL-divergence pushes the variational posterior <span class="math inline">\(q_{\phi}(\textbf{z}_n | \textbf{x}_n)\)</span> towards the prior <span class="math inline">\(p_{\theta}(\textbf{z}_n)\)</span>. In other words the KL-divergence term tries to approximate/regulate that the distribution <span class="math inline">\(q_{\phi}(\textbf{z}_n | \textbf{x}_n)\)</span> (blue circle above) be as close as possible to the distribution of the latent variable <span class="math inline">\(p_{\theta}(\textbf{z}_n)\)</span> (red circle).</p></li>
</ul>
<!-- 46,59
The term is appropriate because  

The reconstruction loss measures the difference between the original input and the ouput generated by the decoder. This is what this equation is doing. IT first samples a z from our approximated posterior q(z|x), and then using p(x|z) reconstructs x.   

We do this by first sampling z from our approximated posterior q(z|x), and then using p(x|z) to reconstruct x. 
Thus this loss measures how well the sample (due to the hint) has been reconstructed. A h


Ideally we want this loss to be as close to zero means means the reconstructed data  -->
</section>
<section id="q1.5" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="q1.5"><span class="header-section-number">6</span> Q1.5</h2>
<p>Passing the derivative through samples can be done using the reparameterization trick. In a few sentences, explain why the act of sampling usually prevents us from computing ∇φL, and how the reparameterization trick solves this problem.</p>
<center>
<img src="https://www.deeplearningbook.com.br/wp-content/uploads/2019/12/form11.png" class="img-fluid">
</center>
<pre></pre>
<p>Img Source at: deeplearningbook.com</p>
<p><strong>Why the act of sampling usually prevents us from computing ∇φL?</strong></p>
<p>This is because sampling <span class="math inline">\(\textbf{z}\)</span> from <span class="math inline">\(q_{\phi}(\textbf{z}_n | \textbf{x}_n)\)</span> directly is not differentiable. To minimize the loss and learn the variational parameters we need this to be differentiable so that we can do backpropagation and thus learn the parameters. This problem can be visualized in the left side of the above picture.</p>
<p>A way to circumvent this problem is by using the reparametrization trick. Essentially we want to be able to rewrite the expectation so that the distribution w.r.t. which we take the gradient is independent of parameter <span class="math inline">\(\phi\)</span>. To achieve this, we can reparametrize a sample from <span class="math inline">\(q_{\phi}(\textbf{z}_n | \textbf{x}_n)\)</span> by expressing it as a function of a sample <span class="math inline">\(\epsilon\)</span> from some distribution <span class="math inline">\(p(\epsilon)\)</span></p>
<p><span class="math display">\[
z = g(\epsilon, \phi)
\]</span></p>
<p>Here <span class="math inline">\(g(\epsilon, \phi)\)</span> is the function that maps <span class="math inline">\(\epsilon\)</span> to <span class="math inline">\(z\)</span>. Importantly, this function needs to be differentiable w.r.t <span class="math inline">\(\phi\)</span>, i.e a Gaussian distribution so that <span class="math inline">\(z\)</span> becomes:</p>
<p><span class="math display">\[
z = \mu + \sigma \, \odot \, \epsilon \quad \text{with}\quad \epsilon \sim  N(0, I) \tag{1}
\]</span></p>
<p>What we accomplish with eq (1) is that now the sampling is done over <span class="math inline">\(\epsilon\)</span>. This means that now we can compute backpropagatin over <span class="math inline">\(\mu, \sigma\)</span> which are deterministic parameters that we can learn to optimize the loss. Recall the loss was composed of two terms the <span class="math inline">\(L_{reg}\)</span> and <span class="math inline">\(L_{recon}\)</span> (which this later is the one we use the reparametrization trick). To wrap up, this idea of sampling with reparametrization can be visualized in the right side of the picture above.</p>
<p><!-- so that our expectation can be rewriten as follows:

$$
\nabla_{\phi} E_{q_{\phi}(z)}[f(z)] = E_{p(\epsilon)}[\nabla_{z}f(z)\nabla_{\phi}g(\epsilon, \phi)]
$$


The above equation this allow us is to compute now the gradient of z to do backprogatation. This is illustrated in the picture above in the right side. There we can see that if i.e  $g(\epsilon, \phi)$ is a Gaussian distribution then we would be able to take its gradient. --> <!-- 
Summing out, we have use this trick so the Montecarlo estimate of the expectation is differentiable w.r.t. $\phi$. This then allow us to compute $L_{recon}$ which is one of the terms that we need to compute the total loss as defined as follows: --></p>
<!-- 

 need to make the stochastic element in  $q_{\phi}(\textbf{z}_n | \textbf{x}_n)$ be independent of $\phi$. Hence, we write $z$ as:

$$
z = \mu + \sigma \, \odot \, \epsilon \quad \text{with}\quad \epsilon \sim  N(0, I)
$$

 -->
<center>
<img src="2023-12-09-20-06-58.png" class="w550 img-fluid">
</center>
<pre></pre>
<p>Img Source at: regorygundersen.com</p>
</section>
<section id="q2.1" class="level2" data-number="7">
<h2 data-number="7" class="anchored" data-anchor-id="q2.1"><span class="header-section-number">7</span> Q2.1</h2>
<ol type="1">
<li>When q(z|x) is a dirac delta distribution the encoder always produce the same latent code z given input x. That means to obtain q(z) we can sample the encoders ouput for a given number of x inputs to obtain this distribution. We can accomplish this because the encoder will map x to a given z (deterministically) so the more you sample from the encoder given a particular x the more we get close to the true distribution q(z). Analytically, this can be expressed as follows:</li>
</ol>
<p><span class="math display">\[
q(z) = \int_{x} q(z|x) p_d(x) dx
\]</span><br>
Where <span class="math inline">\(p_d(x)\)</span> represents the distribution of our data <span class="math inline">\(x\)</span>.</p>
<ol start="2" type="1">
<li><p>When the posterior is a Gaussian distribution then the encoder will predict a mean <span class="math inline">\(\mu\)</span> and std <span class="math inline">\(\sigma\)</span> for each latent variable. To obtain q(z), similarly as the previous case, we can sample from q(z|x) and the resulting distribution will be gaussian with the parameters <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\sigma\)</span> dictated by the encoder’s ouput.</p></li>
<li><p>When an arbitraty complex posterioir distribution is used, we can think of the encoder as a function that takes input x, and random noise <span class="math inline">\(\eta\)</span> to produce a sample from <span class="math inline">\(q(z|x, \eta)\)</span> [Makhzani et al., 2015]. To obtain q(z) similarly as with the previous two methods we will sample as many times possible as to get close to the real distribution. Mathematically, we can express this distribution as follows:</p></li>
</ol>
<p><span class="math display">\[
q(z) = \int_{x} \int_{\eta} q(z|x,\eta) p_d(x) p_{\eta}(\eta) d_{\eta}dx
\]</span><br>
Where <span class="math inline">\(p_{\eta}(\eta)\)</span> represents the distribution to account for the random noise.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Research
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<p>The distribution <span class="math inline">\(q(z)\)</span> in the context of autoencoders is the approximation of the posterior distribution <span class="math inline">\(p(z|x)\)</span>, which is the distribution of the latent variables <span class="math inline">\(z\)</span> given an observation <span class="math inline">\(x\)</span>. The method for computing <span class="math inline">\(q(z)\)</span> depends on the assumptions made about the encoder:</p>
<ol type="1">
<li><strong>Deterministic function (Dirac delta distribution)</strong>:
<ul>
<li>When the encoder is deterministic, <span class="math inline">\(q(z|x)\)</span> is modeled as a Dirac delta distribution centered around a single point, which means it always outputs the same <span class="math inline">\(z\)</span> for the same <span class="math inline">\(x\)</span>.</li>
<li>Mathematically, for a deterministic encoder, <span class="math inline">\(q(z|x) = \delta(z - f(x))\)</span>, where <span class="math inline">\(f(x)\)</span> is the deterministic function mapping <span class="math inline">\(x\)</span> to <span class="math inline">\(z\)</span>. There is no uncertainty in <span class="math inline">\(z\)</span> given <span class="math inline">\(x\)</span>; the output is a single point in the latent space.</li>
<li>To compute <span class="math inline">\(q(z)\)</span>, you would essentially just collect the points <span class="math inline">\(z\)</span> for all <span class="math inline">\(x\)</span> in your dataset, which would give you an empirical distribution of the latent codes.</li>
</ul></li>
<li><strong>Gaussian posterior</strong>:
<ul>
<li>In this case, the encoder outputs parameters of a Gaussian distribution, typically the mean <span class="math inline">\(\mu\)</span> and standard deviation <span class="math inline">\(\sigma\)</span> (or variance <span class="math inline">\(\sigma^2\)</span>) for each latent variable.</li>
<li><span class="math inline">\(q(z|x)\)</span> is then a Gaussian distribution <span class="math inline">\(\mathcal{N}(z; \mu(x), \sigma^2(x))\)</span>, where <span class="math inline">\(\mu(x)\)</span> and <span class="math inline">\(\sigma^2(x)\)</span> are the outputs of the encoder.</li>
<li>To compute <span class="math inline">\(q(z)\)</span>, you sample from the Gaussian distribution parameterized by the mean and variance predicted by the encoder for each input <span class="math inline">\(x\)</span>. During training, the reparameterization trick is often used to allow for gradient backpropagation through the random sampling process.</li>
</ul></li>
<li><strong>Universal approximator posterior</strong>:
<ul>
<li>Here, the encoder is capable of modeling arbitrarily complex distributions, not limited to Gaussian. This can be achieved using normalizing flows, autoregressive models, or other flexible density estimation techniques.</li>
<li><span class="math inline">\(q(z|x)\)</span> in this case could be any parameterizable distribution that the encoder is designed to approximate.</li>
<li>Computing <span class="math inline">\(q(z)\)</span> involves using the encoder to output the parameters that define the distribution for each <span class="math inline">\(x\)</span>, and then sampling from this distribution. Depending on the complexity, different techniques such as Monte Carlo sampling may be employed to approximate samples from <span class="math inline">\(q(z|x)\)</span>.</li>
</ul></li>
</ol>
<p>In each case, the encoder learns to map inputs <span class="math inline">\(x\)</span> to the latent space in a way that captures the underlying distribution of the data. For deterministic encoders, this is straightforward, but for stochastic encoders (like the latter two cases), the process involves learning the parameters of the distributions that can generate the observed data when sampled.</p>
<section id="nd-source" class="level3" data-number="7.1">
<h3 data-number="7.1" class="anchored" data-anchor-id="nd-source"><span class="header-section-number">7.1</span> 2nd Source</h3>
<p><strong>Question 2.1:</strong></p>
<p><strong>How to compute q(z)</strong> based on each of the following encoders:</p>
<ul>
<li><p>A deterministic function, i.e.&nbsp;q(z|x) being a dirac delta distribution</p></li>
<li><p>Gaussian posterior, i.e.&nbsp;the encoder predicts a mean and std per latent</p></li>
<li><p>A universal approximator posterior, i.e.&nbsp;q(z|x) being arbitrary complex distributions</p></li>
</ul>
<p><strong>Answer:</strong></p>
<p><strong>Deterministic function:</strong></p>
<p>If q(z|x) is a dirac delta distribution, then q(z) is simply the distribution of the latent codes z. This distribution can be computed by sampling from the encoder’s output and then taking the average.</p>
<p><strong>Gaussian posterior:</strong></p>
<p>If the encoder predicts a mean and std per latent, then q(z) is a Gaussian distribution with the predicted mean and std.</p>
<p><strong>Universal approximator posterior:</strong></p>
<p>If q(z|x) is an arbitrary complex distribution, then q(z) can be computed by using a sampling-based approach. For example, we can sample from the encoder’s output and then take the average.</p>
</section>
</div>
</div>
</div>
</section>
<section id="q2.2" class="level2" data-number="8">
<h2 data-number="8" class="anchored" data-anchor-id="q2.2"><span class="header-section-number">8</span> Q2.2</h2>
<p>In vanilla GANs, mode collapse problem occur because the generator is unable to produce diverse data samples. This could be as we saw in the lectures with the flowers example that the generator may have picked one single data point that believes it will fool the discriminator. If this strategy is sacksful then the generator has no reason to explore other possible data samples. Thus the generator gets stuck in producing images that look repetitive. AAE mitigate this problem by encouraging/guiding the generator to produce latent codes that are distributed according to p(z). We can do this because the adversarial network provides feedback to the encoder, which is also the generator in this adversarial network, about how well its latent codes match the prior distribution p(z). Thus, this procedure allows to the discriminator to give a signal on how the encoder is doing. Before with vanilla GANs there was not feedback loop that will guide the encoder to be diverse with this second network we regularize the autoencoder from overfitting to the training data.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Research
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<p>Adversarial autoencoders (AAEs) are a type of generative model that can help to reduce the mode collapse problem compared to the vanilla GAN. AAE has the following advantages over GANs:</p>
<ul>
<li><p><strong>Encourages the generator to learn the latent space of the data:</strong> The autoencoder in AAE learns the latent space of the data by compressing and then reconstructing the data. This helps to ensure that the generator learns a representation of the data that is consistent with the latent space.</p></li>
<li><p><strong>Regularizes the generator:</strong> The autoencoder in AAE also acts as a regularizer for the generator. This helps to prevent the generator from overfitting to the data and to instead focus on learning a general representation of the data.</p></li>
<li><p><strong>Constrains the generator to generate realistic data:</strong> The autoencoder in AAE helps to constrain the generator to generate realistic data. This is because the autoencoder needs to be able to reconstruct the data that the generator generates. As a result, the generator is encouraged to generate data that is similar to the data that was used to train the autoencoder.</p></li>
</ul>
<p>Overall, AAE is a more stable and robust method for training GANs than the vanilla GAN. This is because AAE helps to prevent mode collapse and to encourage the generator to learn a good representation of the data. As a result, AAE can be used to train more realistic and diverse generative models.</p>
<p>Here is a table that summarizes the differences between AAE and GANs:</p>
<table class="table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th>Feature</th>
<th>Adversarial Autoencoder (AAE)</th>
<th>Vanilla GAN</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Use of autoencoder</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr class="even">
<td>Regularization</td>
<td>Autoencoder acts as regularizer</td>
<td>No autoencoder</td>
</tr>
<tr class="odd">
<td>Consistency with latent space</td>
<td>Encouraged by autoencoder</td>
<td>Not explicitly encouraged</td>
</tr>
<tr class="even">
<td>Likelihood of mode collapse</td>
<td>Lower</td>
<td>Higher</td>
</tr>
<tr class="odd">
<td>Realism of generated samples</td>
<td>Higher</td>
<td>Lower</td>
</tr>
<tr class="even">
<td>Diversity of generated samples</td>
<td>Higher</td>
<td>Lower</td>
</tr>
</tbody>
</table>
<p>2.2 mine</p>
<p>The distribution q(z) helps the generator guide the generator in generating realistic data samples. The generator of the adversarial network is also the encoder of the autoencoder q(z|x). The goal of the adversarial autoencoder is to train the encoder to produce latent codes that are distributed according to p(z). The adversarial network helps to achieve this goal by providing feedback to the encoder about how well its latent codes match the prior distribution p(z). The discriminator in the adversarial network is trained to distinguish between real data and data that is generated by the autoencoder. The encoder is trained to produce latent codes that are so realistic that the discriminator cannot tell that they are not real.</p>
<p>By using an adversarial network, the adversarial autoencoder can be trained to generate data that is both realistic and diverse.</p>
<p>Once the training procedure is done, the decoder of the autoencoder will define a generative model that maps the imposed prior of p(z) to the data distribution</p>
<section id="nd-source-1" class="level3" data-number="8.1">
<h3 data-number="8.1" class="anchored" data-anchor-id="nd-source-1"><span class="header-section-number">8.1</span> 2nd Source:</h3>
<p><strong>Question 2.2:</strong></p>
<p><strong>How adversarial auto-encoders can reduce the mode collapse problem compared to the vanilla GAN.</strong></p>
<p><strong>Answer:</strong></p>
<p>Adversarial auto-encoders (AAEs) can reduce the mode collapse problem compared to vanilla GANs in a few ways. First, the autoencoder component of the AAE helps to regularize the generator and prevent it from overfitting to the training data. Second, the adversarial component of the AAE helps to encourage the generator to produce diverse samples.</p>
<p>Here is a more detailed explanation of how each of these components contributes to reducing mode collapse:</p>
<ul>
<li><p><strong>Autoencoder regularization:</strong> The autoencoder component of the AAE is trained to reconstruct the input data. This helps to regularize the generator and prevent it from overfitting to the training data. Overfitting is a major cause of mode collapse in GANs, so by preventing overfitting, the AAE can help to reduce mode collapse.</p></li>
<li><p><strong>Adversarial diversity:</strong> The adversarial component of the AAE is trained to distinguish between real data and fake data generated by the generator. This encourages the generator to produce diverse samples, so that it can fool the discriminator. Mode collapse occurs when the generator learns to produce a small number of samples that can fool the discriminator. By encouraging the generator to produce diverse samples, the adversarial component of the AAE can help to reduce mode collapse.</p></li>
</ul>
<p>Overall, AAEs are a more robust and stable method for training GANs than vanilla GANs. This is because AAEs help to prevent overfitting and encourage diversity, which are two common causes of mode collapse in GANs.</p>
<p>AAE can reduce this problem by imposing a prior distribution p(z) on the latent codes as this helps to:</p>
<ol type="1">
<li>Regularize the autoencoder from overfitting to the training data</li>
<li>Guide the generated data to follow a specific distribution p(z) so as to produce diverse samples.</li>
</ol>
<p>This helps to mitigate the mode collapse problem as how we saw the example in the lectures with the flowers. All generated flowers would be similar. There was no diversity. Thus if we can encourage the model to generate diverse samples then we can solve this problem. By guide here we mean that the adversarial network in this architecture will try to make</p>
<p>The distribution q(z) helps the generator guide the generator in generating realistic data samples. The generator of the adversarial network is also the encoder of the autoencoder q(z|x). The goal of the adversarial autoencoder is to train the encoder to produce latent codes that are distributed according to p(z). The adversarial network helps to achieve this goal by providing feedback to the encoder about how well its latent codes match the prior distribution p(z). The discriminator in the adversarial network is trained to distinguish between real data and data that is generated by the autoencoder. The encoder is trained to produce latent codes that are so realistic that the discriminator cannot tell that they are not real.</p>
</section>
</div>
</div>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  let localAlternateSentinel = 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="../../about/index.html"><span class="footerDaniloToapanta">Mantained by Danilo Toapanta</span></a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="../../coming-soon.html">Newsletter</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="../../docs/sitemap.xml">RSS</a>
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>
<script>

    let navbar = document.getElementsByClassName("navbar-nav")[0]    

    let li2 = document.createElement("li");
    li2.className = "nav-item compact";

    let a2 = document.createElement("a");
    a2.className = "nav-link quarto-color-scheme-toggle";
    a2.style.cursor = "pointer"
    li2.appendChild(a2)

    let i2 = document.createElement("i");
    i2.className = "bi bi-moon"
    a2.append(i2)

    navbar.appendChild(li2);

    i2.onclick = function() {
        window.quartoToggleColorScheme(); return false;
    }
    // <a href="http://localhost:4200/about/" class="quarto-color-scheme-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>

    let li = document.createElement("li");
    li.className = "nav-item compact";

    let a = document.createElement("a");
    a.className = "nav-link";
    a.style.cursor = "pointer"
    li.appendChild(a)

    let i = document.createElement("i");
    i.className = "bi bi-search"
    a.append(i)

    // let span = document.createElement("span");
    // span.className = "menu-text"
    // a.append(span)

    navbar.appendChild(li);

    a.onclick = function() {
        window.quartoOpenSearch()
    }


</script>





</body></html>